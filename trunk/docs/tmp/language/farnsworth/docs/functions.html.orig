<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Language::Farnsworth::Docs::Functions - A big reference to all the functions in the Language::Farnsworth Standard Library</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#array_functions">Array Functions</a></li>
	<ul>

		<li><a href="#push__">push[]</a></li>
		<li><a href="#pop__">pop[]</a></li>
		<li><a href="#unshift__">unshift[]</a></li>
		<li><a href="#shift__">shift[]</a></li>
		<li><a href="#sort__">sort[]</a></li>
		<li><a href="#map__">map[]</a></li>
		<li><a href="#length__">length[]</a></li>
		<li><a href="#reverse__">reverse[]</a></li>
		<li><a href="#min___and_max__">min[] and max[]</a></li>
	</ul>

	<li><a href="#string_functions">String Functions</a></li>
	<ul>

		<li><a href="#reverse__">reverse[]</a></li>
		<li><a href="#length__">length[]</a></li>
		<li><a href="#ord__">ord[]</a></li>
		<li><a href="#chr__">chr[]</a></li>
		<li><a href="#index__">index[]</a></li>
		<li><a href="#eval__">eval[]</a></li>
		<li><a href="#substrlen__">substrLen[]</a></li>
		<li><a href="#substr__">substr[]</a></li>
		<li><a href="#left__">left[]</a></li>
		<li><a href="#right__">right[]</a></li>
	</ul>

	<li><a href="#math_functions">Math Functions</a></li>
	<ul>

		<li><a href="#trigonometry_functions">Trigonometry Functions</a></li>
		<li><a href="#miscellaneous_math_functions">Miscellaneous Math Functions</a></li>
		<li><a href="#rounding_functions">Rounding Functions</a></li>
		<li><a href="#functions_for_rational_numbers">Functions for Rational Numbers</a></li>
		<li><a href="#prime_numbers">Prime Numbers</a></li>
		<li><a href="#complex_number_math_functions">Complex Number Math Functions</a></li>
		<li><a href="#random_number_functions">Random Number Functions</a></li>
	</ul>

	<li><a href="#miscellaneous_functions">Miscellaneous Functions</a></li>
	<ul>

		<li><a href="#now__">now[]</a></li>
		<li><a href="#unit__">unit[]</a></li>
	</ul>

</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="description">DESCRIPTION</a></h1>
<p>This document is intended to document all of the functions that Language::Farnsworth includes in its standard library.</p>
<p>
</p>
<hr />
<h1><a name="array_functions">Array Functions</a></h1>
<p>
</p>
<h2><a name="push__">push[]</a></h2>
<pre>
        push[array, elements, ...]</pre>
<p>Push will take an array and place all arguments following the array onto the end.  Just like a <code>stack</code>.</p>
<p>
</p>
<h2><a name="pop__">pop[]</a></h2>
<pre>
        result = pop[array]</pre>
<p>Pop is the antithesis (ED NOTE: need better word!) to push, instead of placing an element on the end of the array, pop[] removes it.</p>
<p>
</p>
<h2><a name="unshift__">unshift[]</a></h2>
<pre>
        unshift[array, elements, ...]</pre>
<p>Unshift is very similar to pop[].  However instead of putting the elements on the end of the array; unshift puts them at the beginning.</p>
<p>
</p>
<h2><a name="shift__">shift[]</a></h2>
<pre>
        shift[array]</pre>
<p>Just as pop is the antithesis (ED NOTE: need better word, STILL!) to push, shift[] is the antithesis to unshift[]</p>
<p>
</p>
<h2><a name="sort__">sort[]</a></h2>
<pre>
        sortedarray = sort[elements, ... ]
        sortedarray = sort[array]
        sortedarray = sort[{`a,b` a &lt;=&gt; b}, elements, ... &gt;]
        sortedarray = sort[{`a,b` a &lt;=&gt; b}, array]</pre>
<p>sort[] will take a series of numbers or strings and sort them into either alphabetical or numerical order.
If you give a lambda as the first argument to sort[] it will use that to do all of the logic for comparing each element of the array.
This lambda must perform the comparison in a stable manner or the results will not be deterministic.  The lambda must take two arguments and then return either a -1, 0, or 1 as the <strong>&lt;=&gt;</strong> operator does.</p>
<p>
</p>
<h2><a name="map__">map[]</a></h2>
<pre>
        mappedarray = map[maplambda, array]
        mappedarray = map[maplambda, elements, ...]
        mappedarray = map[{`x` x + 10}, array]
        mappedarray = map[{`x` x + 10}, elements, ...]</pre>
<p>map[] will take an array or set of elements and pass each element as the first argument to <strong>maplambda</strong> for <strong>maplambda</strong> to transform.
<strong>maplambda</strong> should return the new value for the element to be used in <strong>mappedarray</strong>.</p>
<p>
</p>
<h2><a name="length__">length[]</a></h2>
<pre>
        howmany = length[array]</pre>
<p>When you give length[] and array, it will return how many elements the array has.</p>
<p>
</p>
<h2><a name="reverse__">reverse[]</a></h2>
<pre>
        reversedarray = reverse[array]</pre>
<p>reverse[] will reverse the order of the elements in array and return the result.</p>
<p>
</p>
<h2><a name="min___and_max__">min[] and max[]</a></h2>
<pre>
        minimum = min[array]
        minimum = min[elements, ...]
        maximum = max[array]
        maximum = max[elements, ...]</pre>
<p>These two functions give you the minimum or maximum element from their arguments.</p>
<p>
</p>
<hr />
<h1><a name="string_functions">String Functions</a></h1>
<p>
</p>
<h2><a name="reverse__">reverse[]</a></h2>
<pre>
        reversedstring = reverse[string]</pre>
<p>reverse[] will reverse the order of all the characters in the string.</p>
<p>
</p>
<h2><a name="length__">length[]</a></h2>
<pre>
        howlong = length[string]</pre>
<p>When length[] take either a string as its argument it will return the length of the string in characters, this means that a string with unicode characters like <strong>&quot;日本語&quot;</strong> will have a length of <strong>3</strong>.</p>
<p>
</p>
<h2><a name="ord__">ord[]</a></h2>
<pre>
        codepoint = ord[string]</pre>
<p>ord[] will give you the unicode codepoint of the first character of the string you pass it.</p>
<p>
</p>
<h2><a name="chr__">chr[]</a></h2>
<pre>
        string = chr[codepoint]</pre>
<p>chr[] will take a unicode codepoint and give you back a string containing only that character.</p>
<p>
</p>
<h2><a name="index__">index[]</a></h2>
<pre>
        position = index[string, substring]
        position = index[string, substring, pos]</pre>
<p>index[] will search in <strong>string</strong> for the first occurance of <strong>substring</strong> and return its <strong>position</strong>.  If <strong>substring</strong> is not found in <strong>string</strong> it will return -1.
The optional parameter <strong>pos</strong> will tell index how far into the string to start looking, 0 being the start of the string.</p>
<p>
</p>
<h2><a name="eval__">eval[]</a></h2>
<pre>
        result = eval[string]</pre>
<p>eval[] will take a string and evaluate it as if it were the Language::Farnsworth language and return the result.</p>
<p>
</p>
<h2><a name="substrlen__">substrLen[]</a></h2>
<pre>
        substring = substrLen[string, start, length]</pre>
<p>substrLen[] will pull out a part of <strong>string</strong> that starts at <strong>start</strong> and is <strong>length</strong> characters.  If <strong>length</strong> is longer than the end of <strong>string</strong> then it will <strong>substring</strong> will only contain the text up until the end of the string.</p>
<p>
</p>
<h2><a name="substr__">substr[]</a></h2>
<pre>
        substring = substr[string, start, end]</pre>
<p>substr[] will pull out a part of <strong>string</strong> that starts at <strong>start</strong> and ends at <strong>end</strong></p>
<p>
</p>
<h2><a name="left__">left[]</a></h2>
<pre>
        substring = left[string, length]</pre>
<p>left[] returns the left '<strong>length</strong>' characters from '<strong>string</strong>'.</p>
<p>
</p>
<h2><a name="right__">right[]</a></h2>
<pre>
        substring = right[string, length]</pre>
<p>right[] returns the right '<strong>length</strong>' characters from '<strong>string</strong>'.</p>
<p>
</p>
<hr />
<h1><a name="math_functions">Math Functions</a></h1>
<p>
</p>
<h2><a name="trigonometry_functions">Trigonometry Functions</a></h2>
<pre>
        sin[x]  csc[x]
        cos[x]  sec[x]
        tan[x]  cot[x]
        atan[x] arctan[x]
        acos[x] arccos[x]
        asin[x] arcsin[x]</pre>
<pre>
        sinh[x]
        cosh[x]
        tanh[x]
        atanh[x] arctanh[x]
        acosh[x] arccosh[x]
        asinh[x] arcsinh[x]</pre>
<pre>
        atan2[x, y]</pre>
<p>I will not go into a detailed explination of what these functions are.  They are the basic trigonometric functions, they all take a single number in and return the result.
atan2[x,y] is best explained by wikipedia <a href="http://en.wikipedia.org/w/index.php?title=Atan2&oldid=246845908">http://en.wikipedia.org/w/index.php</a>.</p>
<p>
</p>
<h2><a name="miscellaneous_math_functions">Miscellaneous Math Functions</a></h2>
<pre>

        sqrt[x]</pre>
<p>Returns the square root of <strong>x</strong></p>
<pre>
        exp[x]</pre>
<p>Returns <strong>e ** x</strong>.</p>
<pre>
        ln[x]</pre>
<p>Returns the natural logarithm of <strong>x</strong></p>
<pre>
        log[x]</pre>
<p>returns the logarithm base 10 of <strong>x</strong></p>
<pre>
        abs[x]</pre>
<p>Returns the absolute value of <strong>x</strong></p>
<pre>
        gcd[x, y]</pre>
<p>Returns the greatest common divisor of <strong>x</strong> and <strong>y</strong></p>
<pre>
        lcm[x, y]</pre>
<p>Returns the lowest common multiple of <strong>x</strong> and <strong>y</strong></p>
<pre>
        quad[a, b, c]
        quadratic[a, b, c]</pre>
<p>Returns an array containing the two solutions to the quadratic equation described by the equation</p>
<pre>
        a x^2 + b x + c</pre>
<p>
</p>
<h2><a name="rounding_functions">Rounding Functions</a></h2>
<pre>
        floor[x]        ceil[x]
        int[x]          trunc[x]
        
        rint[x] round[x, digits]</pre>
<p>floor[] and ceil[] do what they say they do.  Both int[] and trunc[] will in fact just truncate a floating point number to an integer, dropping all digits past the decimal point.
rint[] will round the to the nearest integer.  round[x, digits] will round to a specified number of digits, 0 being an integer 1 meaning having one digit past the decimal point.</p>
<p>
</p>
<h2><a name="functions_for_rational_numbers">Functions for Rational Numbers</a></h2>
<pre>
        numerator[x]
        denominator[x]</pre>
<p>Because Language::Farnsworth uses <a href="/docs/Math/Pari.html">the Math::Pari manpage</a> internally for doing all calculations numbers may be represented as a rational number when possible rather than a floating point number in order to preserve precision.
When used on floating point numbers numerator[] will return the number back to you, and denominator[] will return 1.</p>
<p>
</p>
<h2><a name="prime_numbers">Prime Numbers</a></h2>
<pre>
        isprime[x]</pre>
<p>Returns true if <strong>x</strong> is a prime number.</p>
<pre>
        prime[x]</pre>
<p>Returns the <strong>x</strong>th prime number.</p>
<pre>
        nextprime[x]</pre>
<p>Returns the next prime number after <strong>x</strong></p>
<pre>
        precprimep[x]</pre>
<p>Returns the preceeding prime number before <strong>x</strong></p>
<p>
</p>
<h2><a name="complex_number_math_functions">Complex Number Math Functions</a></h2>
<pre>
        conj[x] # conjugate
        norm[x] # normal
        real[x] # gives back the real part of a complex number
        imag[x] # gives back the imaginary part of a complex number</pre>
<p>
</p>
<h2><a name="random_number_functions">Random Number Functions</a></h2>
<pre>

        randmax[x]</pre>
<p>randmax[x] returns a random number between 0 and <strong>x</strong>.</p>
<pre>
        getrseed[]</pre>
<p>returns the current seed for the random number generator.</p>
<pre>
        setrseed[x]</pre>
<p>sets the seed for the random number generator to <strong>x</strong>.</p>
<pre>
        random[]</pre>
<p>returns a random number between 0 and 1 with 30 digits of precision (e.g. 10**30 different random numbers).</p>
<p>
</p>
<hr />
<h1><a name="miscellaneous_functions">Miscellaneous Functions</a></h1>
<p>
</p>
<h2><a name="now__">now[]</a></h2>
<pre>
        now[]</pre>
<p>now[] returns the current date and time as a Language::Farnsworth Date value.</p>
<p>
</p>
<h2><a name="unit__">unit[]</a></h2>
<pre>
        unit[unit]

</pre>
<p>unit[] takes the name of a unit <strong>NOT</strong> as a string (in future releases it will take it as a string or barename), and will always return the value of the unit[] named as such.  This allows you to have access to a unit even when someone has carelessly defined a variable that stomps on that unit.</p>

</body>

</html>
