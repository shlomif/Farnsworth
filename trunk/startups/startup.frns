source := "I'm on CPAN! see Math::Farnsworth there. you can also see the latest changes at svn co https://vdiddy.sexypenguins.com/subversion/frinkbot/modules";
help := "see http://search.cpan.org/~SIMCOP/Math-Farnsworth-0.5.1/lib/Math/Farnsworth/Docs/Syntax.pm for an almost complete tutorial on my language!";
bug := "think you found a bug? file it at http://farnsworth.sexypenguins.com/ OR send an email to farnsworth.rt@gmail.com";

frozen := C[0];
microwavetime{mass isa kg, end isa K, start = frozen isa K, watts = 1000W isa watt, sh = 1 calorie/gram/degC isa calorie/gram/degC} := (mass sh)(end - start)/watts -> "seconds"
mangle{x} := {var s = x -> Dutch -> Japanese -> Arabic -> German -> Chinese -> French -> Hindi; var lang = x -> DetectLanguage; eval["$s -> HindiTo" + lang] };

tracemangle{x} := {var z=[]; var d = x -> Dutch; push[z,[d,d->FromDutch]]; d = d -> DutchToJapanese; push[z,[d, d->FromJapanese]]; d=d -> JapaneseToArabic; push[z,[d,d->FromArabic]]; d=d -> ArabicToGerman; push[z,[d,d->FromGerman]]; d=d -> GermanToChinese; push[z,[d,d->FromChinese]]; d=d -> ChineseToFrench; push[z,[d, d->FromFrench]]; d=d -> FrenchToHindi; push[z,[d, d->FromHindi]]; d=d -> FromHindi; push[z,d]; z};

dutchmangle{x} :=[x -> DutchToEnglish] -> mangle -> EnglishToDutch

[]=>{`` var output=[]; _display = {`` var o=output; output=[]; o}; _print={`x isa ...` output=[output, x]; x}; print{x isa ...} := x => _print; display{} := [] => _display; };


tobase{x isa 1, b = 16 isa 1} := { var getchr = {`x` substrLen["0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_\\| <>/;:'[]{}=+`~.,?", x, 1]};
if ((b < 2)||(b > 93)) {"" + [] /*raise an exception*/}; 

var output = "";

var sign = "";
if (x < 0)
{
sign = "-";
x=-x;
};

if (floor[x] < x)
{var foo; var bar;
 var rounds;
 foo = 1 + floor[log[10**30]/log[b]];
 bar = x > 0 ? 1 + floor[log[x]/log[b]] : 0;
 rounds = bar >= foo ? 0 : foo - bar;

 var i = 0;

 while ((i < rounds) && (floor[x] < x))
 {
   i = i + 1;

   x = x * b;
 };
 i = i + 1;

 x = floor[x];
 while (i = i - 1)
 {
	var c;
			c = x % b;
			x = floor[x / b];
			if (c >= 0) { /*i don't think i need this check, was in original algorithm*/
				output = output + (c => getchr);
			};
 };

 output = output + ".";
};

 if (x <= 0) {output = output + "0";};

 while (x > 0)
 {
	var c;
			c = x % b;
			x = floor[x / b];
			if (c >= 0) { /*i don't think i need this check, was in original algorithm*/
				output = output + (c => getchr);
			};
 };
 sign+reverse[output];
};

frombase{x isa "",y isa 1} := {var sign = 1; if (index[x,"-"] == 0) {sign=-1; x=right[x,length[x]-1];}; var p = index[x,"."]; var e= p>=0?p:length[x]; var getord = {`x` index["0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_\\| <>/;:'[]{}=+`~.,?", x]};var out=[]; var t=0; var s=1; var n = length[x]; while(n>0) {n=n-1;var c=substrLen[x,length[x]-n-1,1]; if (c != "."){e=e-1; var v=(c=>getord); if (v<0 || v >= y) {[]+"" /*throw exception*/};t=t+v*(y**e); };}; p != -1 ? sign t +0.0 : sign t};
ping =!= pong; ping := pong; /*make it respond to ping*/
