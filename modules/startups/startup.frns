source := "You can see my insides at https://vdiddy.sexypenguins.com/subversion/frinkbot/modules BUT do not try to run me, as i have no documentation and i can probably cause your computer to neuter the cats in your neighborhood";
help := "see  http://vdiddy.sexypenguins.com/twiki/bin/view/Farnsworth/LanguageTutorial  for an incomplete tutorial on my language!";
bug := "think you found a bug? file it at http://farnsworth.sexypenguins.com/ OR send an email to farnsworth.rt@gmail.com";

frozen := C[0];
microwavetime{mass isa kg, end isa K, start = frozen isa K, watts = 1000W isa watt, sh = 1 calorie/gram/degC isa calorie/gram/degC} := (mass sh)(end - start)/watts -> "seconds"
phi := (1 + sqrt[5])/2
mangle{x} := {var s = x -> Dutch -> Japanese -> Arabic -> German -> Chinese -> French -> Hindi; var lang = x -> DetectLanguage; eval["\""+s+"\" -> HindiTo" + lang] };

tracemangle{x} := {var z=[]; var d = x -> Dutch; push[z,[d,d->FromDutch]]; d = d -> DutchToJapanese; push[z,[d, d->FromJapanese]]; d=d -> JapaneseToArabic; push[z,[d,d->FromArabic]]; d=d -> ArabicToGerman; push[z,[d,d->FromGerman]]; d=d -> GermanToChinese; push[z,[d,d->FromChinese]]; d=d -> ChineseToFrench; push[z,[d, d->FromFrench]]; d=d -> FrenchToHindi; push[z,[d, d->FromHindi]]; d=d -> FromHindi; push[z,d]; z};

dutchmangle{x} :=[x -> DutchToEnglish] -> mangle -> EnglishToDutch

b := bit
B := byte
yobi ::- 1024^8
zebi ::- 1024^7
exbi ::- 1024^6
pebi ::- 1024^5
tebi ::- 1024^4
gibi ::- 1024^3
mebi ::- 1024^2
kibi ::- 1024^1

Ki :- kibi
Mi :- mebi
Gi :- gibi
Ti :- tebi
Pi :- pebi
Ei :- exbi
Zi :- zebi
Yi :- yobi;


tobase{x isa 1, b = 16 isa 1} := { var getchr = {|x| substrLen["0123456789abcdefghijklmnopqrstuvwxyz", x, 1]};
if ((b < 2)||(b > 36)) {"" + [] /*raise an exception*/}; 

var output = "";

if (floor[x] < x)
{var foo; var bar;
 var rounds;
 foo = 1 + floor[log[10**30]/log[b]];
 bar = x > 0 ? 1 + floor[log[x]/log[b]] : 0;
 rounds = bar >= foo ? 0 : foo - bar;

 var i = 0;

 while ((i < rounds) && (floor[x] < x))
 {
   i = i + 1;

   x = x * b;
 };
 i = i + 1;

 x = floor[x];
 while (i = i - 1)
 {
	var c;
			c = x % b;
			x = floor[x / b];
			if (c >= 0) { /*i don't think i need this check, was in original algorithm*/
				output = output + (c => getchr);
			};
 };

 output = output + ".";
};

 if (x <= 0) {output = output + "0";};

 while (x > 0)
 {
	var c;
			c = x % b;
			x = floor[x / b];
			if (c >= 0) { /*i don't think i need this check, was in original algorithm*/
				output = output + (c => getchr);
			};
 };
 reverse[output];
};
